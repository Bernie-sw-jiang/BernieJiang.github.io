---
layout: post
title:  "身份验证系统演进"
date:   2023-04-24
toc:  true
tags: [其他]
---
登录、授权系统发展史

## Http无状态协议

远古时期，Web基本上就是文档的浏览而已。既然是浏览，服务端不需要记录谁在某一段时间里浏览了什么文档。因此，Web采用了Http作为通信协议，Http是无状态协议，浏览器的每一次请求，服务器会独立处理，不与之前或之后的请求产生关联。

<img src="../assets/img/身份验证系统演进1.png" alt="身份验证系统演进1"/>

但这也同时意味，任何用户都能通过浏览器访问服务端资源，如果想保护服务端的某些资源，必须限制浏览器请求；要限制浏览器请求，必须鉴别浏览器请求，响应合法请求，忽略非法请求；要鉴别浏览器请求，必须清楚浏览器请求状态。

并且随着交互式Web应用的兴起，如在线购物网站等等，马上就面临一个问题，那就是必须记住哪些人往自己的购物车中放商品，也就是说必须把每个人区分开，身份验证系统由此诞生。

## 用户名密码

在身份验证系统发展的早期，网站通过用户名和密码进行登录，这也是所有身份验证的基础：先引导用户到一个登录页面，用户登录成功就从服务端返回另外一个页面，当用户拿到了这个页面就表明已经登录成功，并且用户的身份信息已经在返回之前写入到了页面中。

这样做最大的问题就是一旦用户将这个页面关掉，下一次再打开时仍然需要重新登陆，用户体验非常糟糕。为了能够维持用户的登录状态，Cookie和Session就此诞生。

## Cookie和Session

举个🌰：翔宇经常去的咖啡店有喝五杯咖啡送一杯咖啡的优惠，然而一次性消费五杯咖啡的机会微乎其微，这时就需要某种方式来纪录翔宇的消费数量：

1. 该店的店员很厉害，能记住每位顾客的消费数量，只要顾客一走进咖啡店，店员就知道该怎么对待了。这种做法就是协议本身支持状态。
2. 发给顾客一张卡片，上面记录着消费的数量，一般还有个有效期限。每次消费时，如果顾客出示这张卡片，则此次消费就会与以前或以后的消费相联系起来。这种做法就是在客户端保持状态。
3. 发给顾客一张会员卡，除了卡号之外什么信息也不纪录，每次消费时，如果顾客出示该卡片，则店员在店里的纪录本上找到这个卡号对应的纪录添加消费信息。这种做法就是在服务端保持状态。

由于Http协议是无状态的，且出于种种原因也不希望使之成为有状态的，因此后两种方案就成为现实的选择。Cookie就是客户端保持状态的方案，而Session就是服务端保持状态的方案。只有在顾客持有会员卡，且服务端有卡号记录的情况下，才能调取顾客的信息。

Cookie： 是用户浏览网站时由服务器创建并由用户的网页浏览器存放在用户计算机或其他设备上的小文本文件。

Session：是一种在服务器端保存数据的机制，用来跟踪用户状态的数据结构，可以保存在文件、数据库或者集群中。

<img src="../assets/img/身份验证系统演进2.png" alt="身份验证系统演进2"/>

1. 客户端发起不带Cookie的登录请求
2. 服务端收到请求，在验证通过后建立Session，将用户信息保存在Session中并创建唯一口令SessionId
3. 服务端通过响应头的Set-Cookie来设置Cookie，Cookie中包含SessionId
4. 客户端收到响应并检查响应头Set-Cookie，在本地保存Cookie
5. 之后每次向同域名发起请求时，会自动添加请求头Cookie
6. 服务端收到请求，解析Cookie中的SessionId，就可以判断用户是否登录

通过Cookie+Session的方式虽然可以维持用户的登录状态，但仍然存在一些问题：

- 无法避免 CSRF 攻击：攻击者诱导用户进入第三方网站，在第三方网站中，向被攻击网站发送跨站请求。利用用户在被攻击网站已经获取的登录凭证Cookie，绕过后台的用户验证。
- 服务端需要保存所有用户的SessionId，如果服务端是一个集群，需要将 SessionId 同步到所有机器上，限制了服务端扩展能力，增加了服务器端维护成本。

## Token

Token是服务器生成的一串字符串，以此作为用户身份的令牌。Token与Cookie+Session方式最大的不同是服务器生成的口令不再是固定、无意义的，而是将客户端的一些独有信息+当前时间+其他信息作为原值，经过加密签名后生成。最常见的Token生成方式是JWT（Json Web Token）。

<img src="../assets/img/身份验证系统演进3.png" alt="身份验证系统演进3"/>

1. 客户端发起不带Token的登录请求
2. 服务端收到请求，在验证通过后，生成加密Token
3. 服务端在响应中将Token返回给客户端
4. 客户端收到响应，将Token自由保存
5. 客户端发起携带Token的请求
6. 服务端收到请求，将Token解密后进行对比，并判断Token中的时间戳是否过期。如果有一项不满足，则请求不合法，需要重新登录
7. 验证通过后，根据当前时间重新生成新Token
8. 服务端在响应中将新Token返回给客户端
9. 客户端收到响应，刷新Token

Token方式有以下优点：

- Token经过加密签名，攻击者不知道密钥就无法伪造Token。即使知道了密钥，客户端信息不一致、时间戳过期，也无法通过验证。
- 客户端自由保存Token，不用保存在 Cookie 中，因此支持跨域共享，且可以防止CSRF攻击。
- 服务端无需存放Token，不会对服务端造成压力，即使是服务器集群，也不需要增加维护成本。

## 单点登录SSO

当身份认证的所有问题都得到比较好的解决之后，又出现了一个新的问题：Web系统已由早期的单系统发展成多系统组成的应用群，各个系统又有自己独立的认证方式，导致用户需要记住的账号越来越多，难道用户要一个个登录？

SSO(Single Sign On)出现的初衷，就是为了提供一个全球统一的用户身份服务，达到一次登录就可以访问其它系统的理想状态。相比于单系统登录，SSO需要一个独立、公共的认证中心，只有认证中心能接受用户的用户名密码等安全信息，其他系统不提供登录入口，只接受认证中心的间接授权。

实现SSO的协议有很多，主流协议有 CAS、OAuth、OpenID Connect、SAML。

### CAS

CAS（中央认证服务Central Authentication Service）是一种独立开放指令协议，针对B/S架构的Web多应用单点登录解决方案。

<img src="../assets/img/身份验证系统演进4.png" alt="身份验证系统演进4"/>

但是CAS也面临传统身份验证系统都面临的问题：客户端都是通过使用资源所有者的凭据，向服务端进行身份验证，从而获取受限资源。它虽然能够解决企业内部产品的登录问题，但是为了使第三方产品能够访问受限资源，资源所有者需要与第三方共享凭据，这将会产生一些问题：

- 为了使用的需要，第三方程序需要存储资源拥有者的凭据，任意第三方应用的泄密都会导致用户的密码和受该密码保护的所有数据泄密。
- 资源拥有者只可通过更改密码来撤销第三方应用的权限，无法对单个应用撤权（一旦更改密码，之前授予的所有第三方应用都要重新授权）
- 第三方应用程序通过密码登录拥有了获取用户所有资料的权利，即资源拥有者无法对第三方程序的访问资源、访问时间等进行限制。

### OAuth2

[OAuth](https://oauth.net/2/)（Open Authorization）是一个关于授权的开放网络标准，允许用户通过授权第三方应用一个短期的访问令牌Token，访问他们存储在另外的服务提供者上的信息，而不需要将用户名和密码提供给第三方移动应用或分享他们数据的所有内容。OAuth 在全世界得到广泛应用，目前的版本是 2.0 版。

认证（Authentication）和授权（Authorization）的区别：

- 认证即确认该用户的身份是他所声明的那个人；
- 授权即根据用户身份授予他访问特定资源的权限。
- 当用户登录应用系统时，系统需要先认证用户身份，然后依据用户身份再进行授权。认证与授权需要联合使用，才能让用户真正登入并使用应用系统。

OAuth2有如下几个参与者：

- Resource Owner ：资源所有者，可以进行授权，通常为用户。
- Resource Server ：存放资源的服务器。
- Authorization Server ：授权服务器。
- Third-party application：第三方应用。
  
  <img src="../assets/img/身份验证系统演进5.png" alt="身份验证系统演进5"/>

**流程如下：**

1. 用户打开三方应用以后，三方应用要求用户给予授权。
2. **用户同意给予三方应用授权。**
3. 三方应用使用上一步获得的授权，向认证服务器申请令牌。
4. 认证服务器对三方应用进行认证，确认无误后同意发放令牌，并指定令牌的权限范围和有效期。
5. 三方应用使用令牌，向资源服务器申请获取资源。
6. 资源服务器确认令牌无误，同意向三方应用开放资源。

其中，”用户同意给予三方应用授权“是**关键，**即用户怎样才能给于客户端授权。有了这个授权以后，客户端就可以获取令牌，进而凭令牌获取受限资源。

#### 三方应用注册

对于一个三方应用，如果想要使用OAuth2，那么首先它要在对应服务提供商的开发平台测进行注册备案。三方应用需要提供：

- 应用名称、应用网站域名。
- 回调URL： 在用户同意授权之后，服务提供商会将用户重新导向这个回调URL，这个回调URL要来负责处理授权码或者访问令牌。

应用注册完成之后，服务提供商会颁发给三方应用一个“客户端认证信息”，包括：

- Client ID：唯一ID，目的是鉴别应用身份。
- Client Secret：应用密钥，目的是保证应用来源的可靠性，防止被伪造，只有应用程序和服务提供商两者可知，泄漏后可能会发生用户隐私数据泄漏的风险。
- Scope：申请的授权范围，可选项。

#### OAuth2授权模式

OAuth2.0 定义了四种授权方式：

- 授权码模式（Authorization Code）
- 简化模式（Implicit）
- 密码模式（Resource Owner Password Credentials）
- 客户端模式（Client Credentials）

##### 授权码模式

授权码模式是功能最完整、流程最严密的授权模式。它的特点就是通过三方应用的后台服务器，与认证服务器进行互动。

它适用于那些有后端的 Web 应用。授权码通过前端传送，令牌则是储存在后端，而且所有与资源服务器的通信都在后端完成。这样的前后端分离，可以避免令牌泄漏。

<img src="../assets/img/身份验证系统演进6.png" alt="身份验证系统演进6"/>

<img src="../assets/img/身份验证系统演进7.png" alt="身份验证系统演进7"/>

1. 用户访问三方客户端，三方客户端携带Client Id将用户重定向到认证服务器。
   1. **注意这一步没有发送Client Secret。**此时认证服务器是无法确定第三方应用身份的，因为无法确认第三方应用使用的是自己的Client Id。
2. 用户选择是否给予三方客户端授权。
3. 如果用户给予授权，认证服务器将用户重定向到三方客户端事先指定的"回调URL"，同时附上一个授权码。
   1. **授权码通过重定向的方式发送给第三方应用，这意味着授权码可以在客户端看到，非常危险**。
4. 三方客户端收到授权码。
5. 三方服务端携带授权码、Client Id、Client Secret向认证服务器申请令牌Token。
   1. 这个过程是在三方应用服务端完成的，所以Token不会像授权码一样暴露出去。
   2. 这个过程需要三方应用提供Client Secret，这样授权服务器就可以确认三方身份。
6. 认证服务器确认无误后，向三方服务端发送访问令牌（access token）和更新令牌（refresh token）。
7. 三方服务端通过令牌向资源服务器申请受限资源，并返回给三方客户端。

##### 简化模式

有些 Web 应用是纯前端应用，没有后端。这时就不能用上面的方式了，必须将令牌储存在前端。RFC 6749 就规定了第二种方式，允许直接向前端颁发令牌，这种方式没有授权码这个中间步骤，所以称为 "隐藏式"。

简化模式不通过第三方应用程序的服务器，直接在浏览器中向授权服务器申请令牌，跳过了"授权码"这个步骤，所有步骤在浏览器中完成，令牌对访问者是可见的，且客户端不需要认证。

这种方式把令牌直接传给前端，是很不安全的。因此，只能用于一些安全要求不高的场景，并且令牌的有效期必须非常短，通常就是会话期间有效，浏览器关掉，令牌就失效了。

<img src="../assets/img/身份验证系统演进8.png" alt="身份验证系统演进8"/>

<img src="../assets/img/身份验证系统演进9.png" alt="身份验证系统演进9"/>

1. 三方客户端将用户重定向到认证服务器。
2. 用户决定是否给于客户端授权。
3. 如果用户给予授权，认证服务器将用户重定向到三方客户端事先指定的"回调URL"，同时附上访问令牌。
4. 三方客户端携带授权码向资源服务器申请用户信息。

##### 密码模式

用户向客户端提供自己的用户名和密码。客户端向授权服务器索要授权，但不得存储密码。这通常用在用户对客户端高度信任的情况下，比如客户端是操作系统的一部分，或者由一个著名公司出品。密码模式只有在其他授权模式无法执行的情况下，才会考虑使用。

<img src="../assets/img/身份验证系统演进10.png" alt="身份验证系统演进10"/>

1. 用户向三方客户端提供用户名和密码。
2. 三方客户端将用户名和密码发给认证服务器，向认证服务器请求令牌。
3. 认证服务器确认无误后，向三方客户端提供访问令牌。

##### 客户端模式

客户端模式指用户直接向客户端注册，客户端以自己的名义要求授权服务器提供服务，其实不存在授权问题。

这种授权模式应用的场景是B2B的服务授权，属于企业间数据授权和交互，不需要普通用户的参与，使用这个令牌获取的资源也和用户无关。一般用来提供给我们完全信任的服务端服务。

<img src="../assets/img/身份验证系统演进11.png" alt="身份验证系统演进11"/>

1. 客户端向认证服务器进行身份认证，并要求一个访问令牌。
2. 认证服务器确认无误后，向客户端提供访问令牌。

#### 刷新Token 

从上面的四种授权流程可以看出，最终的目的都是要授权获取令牌，而且授权令牌的权限也非常之大。所以在OAuth2协议中明确表示要设置授权令牌的有效期，那么当授权令牌过期了该怎么办呢？OAuth2提出了一个更新令牌的解决方案。

<img src="../assets/img/身份验证系统演进12.png" alt="身份验证系统演进12"/>

访问令牌（Access Token）：访问受限资源的凭据，它是一个字符串，指定资源访问范围和持续时间。

更新令牌（Refresh Token）：仅用于授权服务器获取 access token 的凭据，从不发送到资源服务器。其目的是在访问令牌过期后，重新获取新的访问令牌，而不需要用户重新确认授权。一个刷新令牌被使用以后，授权服务需要将其废弃，并重新颁发一个刷新令牌。

1. 通过授权流程获取访问令牌。
2. 当访问令牌过期后，访问受限资源时，资源服务器响应“Invalid Token Error”。
3. 三方服务端携带更新令牌，向授权服务器申请最新的访问令牌。
4. 授权服务器返回最新的访问令牌和更新令牌。
5. 三方客户端刷新访问令牌和更新令牌。

参考

[OAuth2.0](https://bytedance.feishu.cn/wiki/wikcnqsNXqY0ID8gVEomLCDmOnc#5hC8w2) 

[OAuth2 介绍](https://bytedance.feishu.cn/wiki/wikcnppil40DcgLSkMg0brInKVf#) 

https://www.ruanyifeng.com/blog/2014/05/oauth_2_0.html

https://tech.bytedance.net/articles/10284?from=lark_all_search

https://www.jianshu.com/p/243b85771be2

https://blog.csdn.net/qq_36389060/article/details/124047449

https://juejin.cn/post/7092675074683043847

https://juejin.cn/post/6879554721875492878

https://juejin.cn/post/6844903780857675790

https://juejin.cn/post/6906009986149646343

https://segmentfault.com/a/1190000030685155

https://juejin.cn/post/7038428356513103908

https://www.freebuf.com/articles/system/252807.html
